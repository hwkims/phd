<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üòä ÎßàÏùå Ï±ôÍπÄ Ï±óÎ¥á</title>
    <meta name="description" content="üßò‚Äç‚ôÄÔ∏è ÎßàÏùå Ï±ôÍπÄÏùÑ ÎèÑÏôÄÏ£ºÎäî Ï±óÎ¥áÏûÖÎãàÎã§.">
    <meta name="keywords" content="ÎßàÏùåÏ±ôÍπÄ, Ï±óÎ¥á, Ïã¨Î¶¨, Í±¥Í∞ï">
    <meta property="og:title" content="üòä ÎßàÏùå Ï±ôÍπÄ Ï±óÎ¥á">
    <meta property="og:description" content="üßò‚Äç‚ôÄÔ∏è ÎßàÏùå Ï±ôÍπÄÏùÑ ÎèÑÏôÄÏ£ºÎäî Ï±óÎ¥áÏûÖÎãàÎã§.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üß†</text></svg>">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <style>
      /* CSS (Ïä§ÌÉÄÏùºÏùÄ Ïù¥Ï†ÑÍ≥º Í±∞Ïùò ÎèôÏùº, ÏùºÎ∂Ä Ï£ºÏÑù Î∞è ÎØ∏ÏÑ∏ Ï°∞Ï†ï) */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #e0e7ff, #d1e1e9);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .chat-wrapper {
            display: flex;
            flex-direction: column; /* Mobile first: stack vertically */
            flex: 1;
            justify-content: center;
            align-items: center; /* Center chat content */
            padding: 20px;
            box-sizing: border-box;
            width: 100%;
        }

      .profile-header {
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          padding: 15px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.2);
          display: flex;
          align-items: center;
          justify-content: center;
          position: sticky;
          top: 0;
          width: 100%;
          max-width: 400px;
          margin: 0 auto;
          box-sizing: border-box;
          z-index: 10;
          border-radius: 15px 15px 0 0;
      }

      .doctor-switch-button {
          background: transparent;
          border: none;
          font-size: 24px;
          color: #6b7280;
          cursor: pointer;
          outline: none;
          padding: 0;
          margin: 0 10px;
          transition: transform 0.1s ease-in-out;
      }

      .doctor-switch-button:hover, .doctor-switch-button:focus {
          transform: scale(1.2);
      }

        .profile-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

      .profile-image {
          width: 70px;
          height: 70px;
          border-radius: 50%;
          object-fit: cover;
          margin-bottom: 5px;
          border: 2px solid rgba(255, 255, 255, 0.3);
      }

      .profile-name {
          font-size: 16px;
          font-weight: bold;
          color: #4b5563;
      }

        .chat-container {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 0 0 15px 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 400px;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            margin: 0 auto;  /* Center horizontally */
            z-index: 1; /* Lower z-index */
        }

        .message {
            margin-bottom: 10px;
            padding: 10px 12px;
            border-radius: 18px;
            word-wrap: break-word;
            max-width: 70%;
            display: inline-block;
            clear: both;
            position: relative;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
        }

        .message.new-message {
            transform: translateY(10px);
            opacity: 0;
        }

        .message.new-message.show {
            transform: translateY(0);
            opacity: 1;
        }

        .user-message {
            background: #60a5fa;
            color: white;
            float: right;
            border-bottom-right-radius: 4px;
        }

        .assistant-message {
            background: #e5e7eb;
            color: #374151;
            float: left;
            border-bottom-left-radius: 4px;
        }

        #input-container {
            display: flex;
            padding: 10px;
            background: rgba(243, 244, 246, 0.9);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            position: sticky;
            bottom: 0;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            box-sizing: border-box;
            z-index: 1;
            border-radius: 0 0 15px 15px;
        }

        #user-input {
            flex-grow: 1;
            border: none;
            border-radius: 20px;
            padding: 10px 12px;
            margin-right: 5px;
            outline: none;
            background: rgba(255, 255, 255, 0.8);
            font-size: 15px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #send-button, #mic-button {
            background: #60a5fa;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 12px;
            cursor: pointer;
            outline: none;
            font-size: 15px;
        }

        #mic-button {
            background: transparent;
            color: #60a5fa;
            font-size: 24px;
            margin-right: 5px;
        }

        #send-button {
            font-size: 20px;
            padding: 10px 14px;
            line-height: 1;
        }

        audio {
            width: 70%;
            margin-top: 5px;
            display: block;
        }

        /* Panel Styles */
      .panel-container {
          display: flex;
          flex-direction: row; /* Arrange panels horizontally */
          justify-content: center; /* Center panels horizontally */
          gap: 20px;  /* Space between panels */
          width: 100%;
      }
      .panel {
          position: relative;  /* For chart titles to be positioned relative to the panel */
          background: rgba(255, 255, 255, 0.9);
          backdrop-filter: blur(10px);
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
          padding: 20px;
          box-sizing: border-box;
          border-radius: 15px;
          margin-bottom: 20px;
          overflow-y: auto; /* Allow vertical scrolling if content overflows */
          max-height: calc(100vh - 40px); /* Limit height, with some margin */
	  width: 300px;
      }
      .charts-panel{
        width: 300px;
      }

      #map {
          width: 100%;
          border-radius: 10px;
          margin-bottom: 20px;
          height: 500px;
      }

      h2 {
          font-size: 18px;
          color: #4b5563;
          margin-bottom: 10px;
          text-align: center;
      }

      #analyze-button {
        background-color: #87ceeb;
        color: #ffffff;
        border: none;
        border-radius: 5px;
        padding: 10px 15px;
        margin-top: 10px;
        cursor: pointer;
        font-size: 16px;
        display: block;
        margin-left: auto;
        margin-right: auto;
        transition: background-color 0.3s ease; /* Smooth transition for hover effect */
      }

    #analyze-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        margin-left: 10px;
        vertical-align: middle;
    }

      @keyframes spin {
          to { transform: rotate(360deg); }
      }

      #ad-contact-button {
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 5px;
          padding: 10px 15px;
          margin-top: 10px;
          cursor: pointer;
          font-size: 16px;
          display: block;
          margin-left: auto;
          margin-right: auto;
          width: fit-content;
      }

      /* Chart Styles */
      .chart-container {
          margin-bottom: -10px;
          position: relative; /* For absolute positioning of titles */
          height: 140px;
      }

      .chart-title {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 15px;
            color: #4b5563;
            z-index: 3;
            background-color: rgba(255,255,255,0.8);

            border-radius: 5px;
        }

      .chartjs-size-monitor, .chartjs-size-monitor-expand, .chartjs-size-monitor-shrink {
          position: static !important;
      }


      /* Mobile Styles */
      @media (max-width: 767px) {

          .panel-toggle {
            position: fixed;
            top: 20px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            color: #4b5563;
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
          }

          #left-toggle {
            left: 10px;
          }
          #right-toggle {
            right: 10px;
          }
          .chat-container{
            border-radius: 15px;
          }

          .charts-panel, .right-panel { /* Target both panels */
            position: fixed; /* Fixed position for mobile */
            top: 0;
            height: 100vh;
            width: 300px;
            z-index: 1000;
            transform: translateX(100%); /* Hide by default */
            transition: transform 0.3s ease;
            overflow-y: auto;
            margin: 0;
          }

            .charts-panel {
                left: 0; /* Charts panel slides in from the left */
                transform: translateX(-100%); /* Hide to the left */
            }

            .right-panel{
                right:0;
            }

            .charts-panel.open, .right-panel.open {
                transform: translateX(0); /* Slide in when open */
            }

            .chart-container {
               height: 140px; /* Smaller height on mobile */
            }
        }

        /* Desktop Styles */
        @media (min-width: 768px) {
            .chat-wrapper {
                flex-direction: row; /* Arrange items horizontally */
                align-items: flex-start;
                justify-content: center; /* Center horizontally */
                gap: 20px; /* Space between chat and panels */
            }

            .profile-header, .chat-container, #input-container {
                margin: 0; /* Remove auto margins on desktop */
            }

            .chat-container {
                flex: 0 0 400px;
                margin-top: 20px;
                margin-bottom: 20px;
            }

            .panel-container {
                flex-direction: row; /* Arrange panels horizontally */
                gap: 20px;
            }
            .charts-panel{
                max-height: none;
                overflow-y: visible;
            }

            .panel-toggle {
                display: none; /* Hide toggle buttons on larger screens */
            }
        }
    </style>
</head>
<body>
    <div class="chat-wrapper">
        <!-- Left Panel (Charts - initially hidden on mobile) -->
        <div class="charts-panel panel">
            <h2>ÎÇ¥ ÎßàÏùå ÏÉÅÌÉú üòä</h2>
             <button id="analyze-button">Î∂ÑÏÑù!</button>
            <div class="chart-container">
                <div class="chart-title">Í¥ÄÍ≥Ñ-Ï†ïÏÑú (E/I)</div>
                <canvas id="mental-graph1"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Ï†ïÎ≥¥-Ïù∏ÏßÄ (S/N)</div>
                <canvas id="mental-graph2"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Í∞ÄÏπò-ÌåêÎã® (T/F)</div>
                <canvas id="mental-graph3"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Ïã§Ìñâ-Í¥ÄÎ¶¨ (J/P)</div>
                <canvas id="mental-graph4"></canvas>
            </div>
        </div>

        <!-- Chat Area (Centered) -->
        <div>
            <div class="profile-header">
                <button id="prev-doctor" class="doctor-switch-button">‚óÄ</button>
                <div class="profile-info">
                    <img src="doctor1.jpg" alt="Doctor Image" id="profile-image" class="profile-image">
                    <div id="profile-name" class="profile-name"></div>
                </div>
                <button id="next-doctor" class="doctor-switch-button">‚ñ∂</button>
            </div>

            <div class="chat-container">
                <div id="chat-log"></div>
            </div>

            <div id="input-container">
                <button id="mic-button">üé§</button>
                <input type="text" id="user-input" placeholder="Ïñ¥Îñ§ Í≥†ÎØºÏù¥ ÏûàÎÇòÏöî? üòä" autofocus>
                <button id="send-button">‚û§</button>
            </div>
        </div>

        <!-- Right Panel (Map) -->
        <div id="right-panel" class="panel right-panel">
            <h2>Í∑ºÏ≤ò Ï†ïÏã†Í≥º Î≥ëÏõê üè•</h2>
            <div id="map"></div>
            <a href="tel:010-3330-6884" id="ad-contact-button">Í¥ëÍ≥† Î¨∏Ïùò</a>
        </div>
    </div>

    <!-- Panel Toggle Buttons (for mobile) -->
    <button id="left-toggle" class="panel-toggle">Î∂ÑÏÑù üòä</button>
    <button id="right-toggle" class="panel-toggle">ÏßÄÎèÑ üè•</button>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      // JavaScript (Î°úÏßÅÏùÄ Ïù¥Ï†ÑÍ≥º Í±∞Ïùò ÎèôÏùº, CSS ÌÅ¥ÎûòÏä§, Î™®Î∞îÏùº Ïä¨ÎùºÏù¥Îìú Î©îÎâ¥ Í¥ÄÎ†® ÏàòÏ†ï)
        const API_SERVER_URL = "";  //  API ÏÑúÎ≤Ñ URL (Î∞±ÏóîÎìú Î∞∞Ìè¨ ÌõÑ ÏàòÏ†ï)
        const doctors = { // ÏùòÏÇ¨ Ï†ïÎ≥¥
            doctor1: { name: "Dr. Nova", voice: "nova", image: "doctor1.jpg", greeting: "ÏïàÎÖïÌïòÏÑ∏Ïöî! Ï†ÄÎäî Dr. NovaÏòàÏöî üòä Ï†ïÏã† Í±¥Í∞ïÏóê ÎåÄÌï¥ Ìé∏ÌïòÍ≤å Ïù¥ÏïºÍ∏∞ ÎÇòÎàå Ïàò ÏûàÎäî ÏπúÍµ¨ Í∞ôÏùÄ Ï°¥Ïû¨ÎûçÎãàÎã§. Ï†úÍ∞Ä ÏßÑÏßú ÏùòÏÇ¨Îäî ÏïÑÎãàÎãàÍπå, Ïã¨Í∞ÅÌïú Î¨∏Ï†úÎäî Íº≠ Ï†ÑÎ¨∏Í∞ÄÏôÄ ÏÉÅÎã¥Ìï¥Ï£ºÏÑ∏Ïöî! Ïò§Îäò Í∏∞Î∂ÑÏù¥ Ïñ¥Îñ†Ïã†Í∞ÄÏöî?" },
            doctor2: { name: "Dr. Shimmer", voice: "shimmer", image: "doctor2.jpg", greeting: "ÏïàÎÖïÌïòÏÑ∏Ïöî~ Ï†ÄÎäî Dr. ShimmerÎùºÍ≥† Ìï¥Ïöî! üòÑ Ïó¨Í∏∞ÏÑú Ïó¨Îü¨Î∂ÑÏùò Ïù¥ÏïºÍ∏∞Î•º Îì§Ïñ¥Ï§ÑÍ≤åÏöî. Ï†ÄÎäî AIÎùºÏÑú ÏßÑÏßú ÏùòÏÇ¨Îäî ÏïÑÎãàÏßÄÎßå, ÏµúÎåÄÌïú ÎèÑÏõÄ ÎìúÎ¶¥Í≤åÏöî. ÌòπÏãú Î¨¥Ïä® Í≥†ÎØº ÏûàÏúºÏã†Í∞ÄÏöî?" },
            doctor3: { name: "Dr. Fable", voice: "fable", image: "doctor3.jpg", greeting: "ÏïàÎÖï! Ï†ÄÎäî Dr. FableÏù¥ÏóêÏöî üòä Ïó¨Îü¨Î∂ÑÏùò ÎßàÏùåÏùÑ Îî∞ÎúªÌïòÍ≤å ÏïàÏïÑÏ§Ñ Ï§ÄÎπÑÍ∞Ä ÎêòÏñ¥ ÏûàÎãµÎãàÎã§. Ï†úÍ∞Ä Ï†ÑÎ¨∏ ÏùòÏÇ¨Îäî ÏïÑÎãàÎãà, Ï§ëÏöîÌïú Í±¥ Íº≠ Î≥ëÏõêÏóêÏÑú Ï≤¥ÌÅ¨Ìï¥Ï£ºÏÑ∏Ïöî. Ïò§Îäò Î≠êÍ∞Ä ÎßàÏùåÏóê Í±∏Î¶¨ÏÑ∏Ïöî?" },
        };

        // Í∞Å ÏßÄÌëúÏóê ÎåÄÌïú Ïù¥Î¶Ñ
        const NEW_MENTAL_SCORES = {
            "scores": {
                "RE1": "ÏÇ¨ÌöåÏ†Å ÏÉÅÌò∏ÏûëÏö© Ï∂îÍµ¨",
                "RE2": "Ï†ïÏÑúÏ†Å ÏïàÏ†ïÏÑ±",
                "RE3": "Í¥ÄÍ≥Ñ ÏßÄÌñ•ÏÑ±",
                "RE4": "ÏûêÍ∏∞ÌëúÌòÑ Î∞è Ï£ºÏû•",
                "IC1": "Ï∞ΩÏùòÏ†Å ÏÇ¨Í≥†",
                "IC2": "ÏßÅÍ¥Ä Î∞è ÌÜµÏ∞∞",
                "IC3": "ÎπÑÌåêÏ†Å ÏÇ¨Í≥†",
                "IC4": "ÌïôÏäµ Î∞è ÏßÄÏãù ÌôïÏû•",
                "VP1": "Í≥µÍ∞ê Î∞è Ï†ïÏÑúÏ†Å ÍµêÎ•ò",
                "VP2": "Ïú§Î¶¨ Î∞è ÎèÑÎçïÏ†Å Í∞ÄÏπò",
                "VP3": "ÏπúÏÇ¨ÌöåÏ†Å ÌñâÎèô",
                "VP4": "Í∞úÎ∞©ÏÑ± Î∞è ÏàòÏö©ÏÑ±",
                "EM1": "Ïú†Ïó∞ÏÑ± Î∞è Ï†ÅÏùëÎ†•",
                "EM2": "ÏûêÍ∏∞Ï£ºÎèÑÏÑ±",
                "EM3": "Ïä§Ìä∏Î†àÏä§ ÎåÄÏ≤ò",
                "EM4": "ÏûêÍ∏∞ÏÑ±Ï∞∞ Î∞è ÏÑ±Ïû•"
            }
        };

        let selectedDoctor = "doctor1";  // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏùòÏÇ¨
        let currentDoctorIndex = 0; // ÏùòÏÇ¨ Ïù∏Îç±Ïä§
        let chatHistory = [];       // ÎåÄÌôî Í∏∞Î°ù
        let mapInitialized = false; // ÏßÄÎèÑ Ï¥àÍ∏∞Ìôî Ïó¨Î∂Ä
        let map;                    // Leaflet Îßµ Í∞ùÏ≤¥
        let mentalCharts = [];      // Ï∞®Ìä∏ Í∞ùÏ≤¥ Î∞∞Ïó¥

		// DOM ÏöîÏÜå
        const chatLog = document.getElementById('chat-log');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');
        const chartsPanel = document.getElementsByClassName("charts-panel")[0]; // Get the charts panel
        const rightPanel = document.getElementById('right-panel');
        const leftToggle = document.getElementById('left-toggle');
        const rightToggle = document.getElementById('right-toggle');
        const profileImage = document.getElementById("profile-image");
        const profileName = document.getElementById("profile-name");
        const prevDoctorButton = document.getElementById("prev-doctor");
        const nextDoctorButton = document.getElementById("next-doctor");
        const analyzeButton = document.getElementById("analyze-button");

		// ÏùòÏÇ¨ Ïù∏Îç±Ïä§
        function getDoctorIndex(doctorKey) {
            return Object.keys(doctors).indexOf(doctorKey);
        }

		// ÏùòÏÇ¨ ÌÇ§
        function getDoctorKey(index) {
            return Object.keys(doctors)[index];
        }

		// Ï¥àÍ∏∞ ÏùòÏÇ¨
        async function loadInitialDoctor() {
            try {
                const response = await fetch(`${API_SERVER_URL}/initial_doctor`);
                if (!response.ok) throw new Error(`Failed to load initial doctor: ${response.status}`);
                const data = await response.json();
                selectedDoctor = data.selected_doctor;
                currentDoctorIndex = getDoctorIndex(selectedDoctor);
                updateDoctorUI();
                displayMessage(doctors[selectedDoctor].greeting, "assistant");
                renderInitialGraph(); // Ï¥àÍ∏∞ Í∑∏ÎûòÌîÑ
            } catch (error) {
                console.error(error);
                // Fallback: If initial doctor loading fails, use the default doctor
                updateDoctorUI();
                displayMessage(doctors[selectedDoctor].greeting, "assistant");
                renderInitialGraph(); // Ï¥àÍ∏∞ Í∑∏ÎûòÌîÑ
            }
        }

		// UI
        function updateDoctorUI() {
            const doctor = doctors[selectedDoctor];
            profileImage.src = doctor.image;
            profileImage.alt = doctor.name;
            profileName.textContent = doctor.name;
        }

		// ÏùòÏÇ¨ ÏÑ†ÌÉù
        async function selectDoctor(doctorKey) {
            try {
                const response = await fetch(`${API_SERVER_URL}/select_doctor`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ selected_doctor: doctorKey }),
                });
                if (!response.ok) throw new Error(`Failed to select doctor: ${response.status}`);

                selectedDoctor = doctorKey;
                currentDoctorIndex = getDoctorIndex(selectedDoctor);
                updateDoctorUI();
                chatLog.innerHTML = ''; // ÎåÄÌôî ÎÇ¥Ïö© ÎπÑÏö∞Í∏∞
                chatHistory = []; // Í∏∞Î°ù ÏÇ≠Ï†ú
                displayMessage(doctors[selectedDoctor].greeting, "assistant"); // ÏÉà Ïù∏ÏÇ¨Îßê
                renderInitialGraph(); // Í∑∏ÎûòÌîÑ

            } catch (error) {
                console.error("Error selecting doctor:", error);
            }
        }

		// ÏùòÏÇ¨ Î≥ÄÍ≤Ω Î≤ÑÌäº
        prevDoctorButton.addEventListener("click", () => {
            currentDoctorIndex = (currentDoctorIndex - 1 + Object.keys(doctors).length) % Object.keys(doctors).length;
            selectDoctor(getDoctorKey(currentDoctorIndex));
        });

        nextDoctorButton.addEventListener("click", () => {
            currentDoctorIndex = (currentDoctorIndex + 1) % Object.keys(doctors).length;
            selectDoctor(getDoctorKey(currentDoctorIndex));
        });

		// Î©îÎâ¥
        leftToggle.addEventListener('click', () => {
          chartsPanel.classList.toggle('open');
          if (rightPanel.classList.contains('open')) { // Only one panel at a time
            rightPanel.classList.remove('open');
          }
        });

        rightToggle.addEventListener('click', () => {
          rightPanel.classList.toggle('open');
          if (chartsPanel.classList.contains('open')) { // Only one panel at a time
            chartsPanel.classList.remove('open');
          }
          if (!mapInitialized && rightPanel.classList.contains('open')) {
            initMap(); // Initialize map when the panel opens
            mapInitialized = true;
          }
        });

		// Î©îÏãúÏßÄ
        function displayMessage(message, role, audioUrl = null) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role === 'user' ? 'user-message' : 'assistant-message');
            messageDiv.textContent = message;

            if (role === 'assistant' && audioUrl) {
                const audioElement = document.createElement('audio');
                audioElement.controls = true;
                audioElement.src = audioUrl;
                audioElement.autoplay = true; // ÏûêÎèôÏû¨ÏÉù
                messageDiv.appendChild(audioElement);
            }
            messageDiv.classList.add('new-message'); // Transition
            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight; // Scroll to the bottom
            setTimeout(()=> messageDiv.classList.add('show'), 10); // Animation
        }

		// Î©îÏãúÏßÄ, Ïò§ÎîîÏò§
        async function getResponseAndTTS(userMessage) {
            try {
                // 1. Ï±óÎ¥á ÏùëÎãµ
                const chatResponse = await fetch(`${API_SERVER_URL}/chat`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ user_message: userMessage, selected_doctor: selectedDoctor }),
                });
                if (!chatResponse.ok) throw new Error(`Chat API call failed: ${chatResponse.status}`);

                const chatData = await chatResponse.json();
                const chatbotResponse = chatData.response;
                chatHistory.push({ role: "user", content: userMessage }, { role: "assistant", content: chatbotResponse });

                // 2. TTS (Ï±óÎ¥á ÏùëÎãµ -> ÏùåÏÑ±)
                let audioUrl = null;
                if(isRecording){ //ÎÖπÏùå Ï§ë ÏùºÎïåÎßå ÏùåÏÑ± Ï∂úÎ†•
                    const ttsResponse = await fetch(`${API_SERVER_URL}/tts`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ user_message: chatbotResponse, selected_doctor: selectedDoctor }),
                    });
                    if (!ttsResponse.ok) throw new Error(`TTS API call failed: ${ttsResponse.status}`);
                    const ttsData = await ttsResponse.json();
                    const audioData = base64ToArrayBuffer(ttsData.audio);
                    const audioBlob = new Blob([audioData], { type: "audio/mpeg" });
                    audioUrl = URL.createObjectURL(audioBlob);
                }
                return { chatbotResponse, audioUrl };

            } catch (error) {
                console.error("Error getting response or TTS:", error);
                displayMessage("Ïïó, Î≠îÍ∞Ä ÏûòÎ™ªÎêêÏñ¥Ïöî üòÖ Îã§Ïãú ÏãúÎèÑÌï¥Î≥ºÍ≤åÏöî!", "assistant"); // Error message
                return { chatbotResponse: null, audioUrl: null };
            }
        }

        // Base64 -> ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

		    // Ï¥àÍ∏∞ Í∑∏ÎûòÌîÑ
        function renderInitialGraph() {
            const scores = NEW_MENTAL_SCORES.scores; // Initial scores (all 50)
            const labels = Object.values(scores);
            const dataValues = Object.keys(scores).map(key => 50); // All 50 initially
            const chunkSize = Math.ceil(labels.length / 4); // Split into 4 groups
            const groupNames = ["Í¥ÄÍ≥Ñ-Ï†ïÏÑú (E/I)", "Ï†ïÎ≥¥-Ïù∏ÏßÄ (S/N)", "Í∞ÄÏπò-ÌåêÎã® (T/F)", "Ïã§Ìñâ-Í¥ÄÎ¶¨ (J/P)"];

            const backgroundColors = [
              'rgba(54, 162, 235, 0.7)',  // Blue
              'rgba(255, 99, 132, 0.7)', // Red
              'rgba(75, 192, 192, 0.7)', // Teal
              'rgba(255, 206, 86, 0.7)'  // Yellow
            ];

            mentalCharts.forEach(chart => chart.destroy()); // Clear previous charts
            mentalCharts = [];

            for (let i = 0; i < 4; i++) {
              const canvasId = `mental-graph${i + 1}`;
              const ctx = document.getElementById(canvasId).getContext('2d');

              const dataset = {
                label: groupNames[i], // Use group names
                data: dataValues.slice(i * chunkSize, (i + 1) * chunkSize),
                backgroundColor: backgroundColors[i % backgroundColors.length],
                borderColor: backgroundColors[i % backgroundColors.length].replace('0.7', '1'),
                borderWidth: 1
              };

              const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                  labels: labels.slice(i * chunkSize, (i + 1) * chunkSize).map(() => ""), // Empty labels
                  datasets: [dataset]
                },
                options: {
                  indexAxis: 'y',
                  scales: {
                    x: { beginAtZero: true, max: 100, grid: { color: 'rgba(0, 0, 0, 0.1)' } },
                    y: { grid: { display: false }, ticks: { display: false } } // Hide y-axis labels
                  },
                  plugins: {
                    legend: { display: false },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const index = context.dataIndex + i * chunkSize;
                          return `${labels[index]}: ${context.raw}`; // Show full label and value
                        }
                      }
                    }
                  },
                  layout: { padding: { left: 10, right: 20, top: 10, bottom: 30 } }
                }
              });
              mentalCharts.push(chart);
            }
          }

		    // Í∑∏ÎûòÌîÑ
    async function updateMentalAnalysis() {
        analyzeButton.disabled = true; // Disable the button
        const spinner = document.createElement('span');
        spinner.classList.add('loading-spinner');
        analyzeButton.appendChild(spinner); // Add a loading spinner

        try {
            const response = await fetch(`${API_SERVER_URL}/analyze_mental_health`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_history: chatHistory })
            });
            if (!response.ok) throw new Error(`Mental Health API call failed: ${response.status}`);

            const data = await response.json();
            if (!data.scores) throw new Error("Analysis result does not contain 'scores'!");

            const scores = data.scores; // Updated scores
            const labels = Object.values(NEW_MENTAL_SCORES.scores);
            const dataValues = Object.keys(NEW_MENTAL_SCORES.scores).map(key => (scores[key] + 50) || 50);  // Add 50 to center the values
            const chunkSize = Math.ceil(labels.length / 4);
            const groupNames = ["Í¥ÄÍ≥Ñ-Ï†ïÏÑú (E/I)", "Ï†ïÎ≥¥-Ïù∏ÏßÄ (S/N)", "Í∞ÄÏπò-ÌåêÎã® (T/F)", "Ïã§Ìñâ-Í¥ÄÎ¶¨ (J/P)"];

            const backgroundColors = [
                'rgba(54, 162, 235, 0.7)',  // Blue
                'rgba(255, 99, 132, 0.7)', // Red
                'rgba(75, 192, 192, 0.7)', // Teal
                'rgba(255, 206, 86, 0.7)'  // Yellow
            ];

            mentalCharts.forEach(chart => chart.destroy()); // Clear previous charts
            mentalCharts = [];

            for (let i = 0; i < 4; i++) {
                const canvasId = `mental-graph${i + 1}`;
                const ctx = document.getElementById(canvasId).getContext('2d');
                const dataset = {
                    label: groupNames[i], // Use group names
                    data: dataValues.slice(i * chunkSize, (i + 1) * chunkSize),
                    backgroundColor: backgroundColors[i % backgroundColors.length],
                    borderColor: backgroundColors[i % backgroundColors.length].replace('0.7', '1'),
                    borderWidth: 1
                };

                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels.slice(i * chunkSize, (i + 1) * chunkSize).map(() => ""), // Empty labels
                        datasets: [dataset]
                    },
                        options: {
                        indexAxis: 'y',
                        scales: {
                            x: {
                                beginAtZero: true,
                                max: 100,  // Keep max at 100 for the 0-100 scale
                                grid: { color: 'rgba(0, 0, 0, 0.1)' },
                                ticks: {
                                    color: '#4b5563', // Tick color
                                    font: { size: 14 } // Tick font size
                                }
                            },
                            y: {
                                grid: { display: false },
                                ticks: { display: false } // Hide y-axis labels
                            }
                        },
                        plugins: {
                            legend: { display: false }, // Hide legend
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const index = context.dataIndex + i * chunkSize;
                                        return `${labels[index]}: ${context.raw}`; // Show label and value
                                    }
                                }
                            }
                        },
                        layout: {
                            padding: { left: 10, right: 20, top: 10, bottom: 30 }
                        }
                    }
                });
                mentalCharts.push(chart);
            }

        } catch (error) {
            console.error("Error updating mental analysis:", error);
        } finally {
            analyzeButton.disabled = false; // Re-enable the button
            analyzeButton.removeChild(spinner); // Remove the spinner
        }
    }
		// ÏßÄÎèÑ
        function initMap() {
            map = L.map('map').setView([37.358694, 127.104994], 15); // Set initial view and zoom level (Î∂ÑÎãπ ÎÇ¥ÎßàÏùå Ï†ïÏã†Í±¥Í∞ïÏùòÌïôÍ≥º)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add a marker for the default location (Î∂ÑÎãπ ÎÇ¥ÎßàÏùå Ï†ïÏã†Í±¥Í∞ïÏùòÌïôÍ≥º)
            L.marker([37.358694, 127.104994]).addTo(map)
                .bindPopup("Î∂ÑÎãπ ÎÇ¥ÎßàÏùå Ï†ïÏã†Í±¥Í∞ïÏùòÌïôÍ≥º ÏùòÏõê")
                .openPopup();

            // Get the user's current location
            navigator.geolocation.getCurrentPosition(
                position => {
                    // Success callback: Set the map view to the user's location and add a marker
                    const userLat = position.coords.latitude;
                    const userLon = position.coords.longitude;
                    map.setView([userLat, userLon], 15); // Set view to user's location
                    L.marker([userLat, userLon]).addTo(map).bindPopup("ÌòÑÏû¨ ÏúÑÏπò üòä").openPopup();
                },
                error => {
                    // Error callback: Log the error (you can handle different error types here)
                    console.error("Geolocation error:", error);
                    // (Optional) Display a message to the user on the page
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 } // Geolocation options
            );
        }

        // Function to send a message and handle the response
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return; // Don't send empty messages

            displayMessage(message, 'user');
            userInput.value = ''; // Clear the input
            userInput.focus();  // Keep focus on the input

            const { chatbotResponse, audioUrl } = await getResponseAndTTS(message);
            if (chatbotResponse) {
                displayMessage(chatbotResponse, 'assistant', audioUrl);
            }
        }

        // Event listener for the send button
        sendButton.addEventListener('click', sendMessage);

        // Event listener for the Enter key in the input field
        userInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
                event.preventDefault(); // Prevent default behavior (like adding a new line)
            }
        });

        // Event listener for the analyze button
        analyzeButton.addEventListener('click', updateMentalAnalysis);


        // Speech recognition setup
        let recognition;
        let isRecording = false; // Flag to check if recording is in progress
        if ('webkitSpeechRecognition' in window) {  // Check for browser support
            recognition = new webkitSpeechRecognition();
            recognition.continuous = true;     // Keep listening even after the user stops talking
            recognition.interimResults = true;  // Get interim results
            recognition.lang = 'ko-KR';        // Set language to Korean

            recognition.onresult = (event) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    }
                }
                if (finalTranscript) {
                    userInput.value = finalTranscript; // Set the input field value
                }
            };

            recognition.onstart = () => {
                isRecording = true;
                micButton.style.color = 'red';     // Change microphone color to red
                micButton.textContent = '‚ñ†';      // Change icon to a stop icon (e.g., a square)
            };

            recognition.onend = () => {
                isRecording = false;
                micButton.style.color = '#60a5fa';  // Change microphone color back
                micButton.textContent = 'üé§';      // Change icon back to microphone
            };

            micButton.addEventListener('click', () => {
                if (isRecording) {
                    recognition.stop(); // Stop recognition
                } else {
                    recognition.start(); // Start recognition
                }
            });
        } else {
            // Hide the microphone button if speech recognition is not supported
            micButton.style.display = 'none';
        }

        // Initial setup
        loadInitialDoctor(); // Load initial doctor info and greeting
        // Initialize map on page load for desktop, or when right panel opens on mobile
        if (window.innerWidth >= 768) {
          initMap();
          mapInitialized = true;
        }
    </script>
</body>
</html>